## Article

```catala
declaration scope S:
  internal f content integer depends on integer
  input x content boolean
  output z content integer

scope S:
  definition f of y equals if x then y else - y
  definition z equals f of -1
```

```catala-test-inline
$ catala Lcalc -s S
let S =
  λ (S_in: S_in {"x_in": bool}) →
    let x : bool = S_in."x_in" in
    let f : integer → integer =
      try
        (λ (param: integer) →
           try
             handle_default [] (λ (_: unit) → true)
               (λ (_: unit) → if x then param else - param) with
             EmptyError -> raise NoValueProvided) with EmptyError ->
        raise NoValueProvided in
    let z : integer =
      try handle_default [] (λ (_: unit) → true) (λ (_: unit) → f -1)
        with EmptyError -> raise NoValueProvided in
    S { "z"= z }
```


```catala-test-inline
$ catala OCaml --avoid_exceptions -O --closure_conversion
(** This file has been generated by the Catala compiler, do not edit! *)

open Runtime_ocaml.Runtime

[@@@ocaml.warning "-4-26-27-32-41-42"]

module S = struct
  type t = {z: integer}
end

module SIn = struct
  type t = {x_in: bool}
end



let s (s_in: SIn.t) : S.t =
  let x_: _ = s_in.SIn.x_in in
  let f_: _ = (let s : _ =
                 (fun (env_: _) (param_: integer) ->
                    (let x_ : _ = (let _, x = env_ in x)
                    in
                    ( if x_ then param_ else (~-! param_)))) in
    (s, x_)) in
  let z_: _ = (((let env_ : _ = (f_)
    in
    (let code_ : _ = (let x, _ = env_ in x)
    in
    (code_ env_ ((integer_of_string "-1"))))))) in
  {S.z = z_}
```

