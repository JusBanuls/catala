## Article

```catala
declaration scope S:
  internal f content integer depends on integer
  input x content boolean
  output z content integer

scope S:
  definition f of y equals if x then y else - y
  definition z equals f of -1
```

```catala-test-inline
$ catala Lcalc -s S --avoid_exceptions -O --closure_conversion
let S =
  λ (S_in: S_in {"x_in": bool}) →
    let x : any = S_in."x_in" in
    let f : any =
      let S : any =
        λ (env: any) (param: integer) →
          let x1 : any = env.1 in
          if x1 then param else - param in
      (S, x) in
    let z : any = let env : any = f in
      let code : any = env.0 in
      code env -1 in
    S { "z"= z }
```


```catala-test-inline
$ catala OCaml --avoid_exceptions -O --closure_conversion
(** This file has been generated by the Catala compiler, do not edit! *)

open Runtime_ocaml.Runtime

[@@@ocaml.warning "-4-26-27-32-41-42"]

module S = struct
  type t = {z: integer}
end

module SIn = struct
  type t = {x_in: bool}
end



let s (s_in: SIn.t) : S.t =
  let x_: _ = s_in.SIn.x_in in
  let f_: _ = (let s : _ =
                 (fun (env_: _) (param_: integer) ->
                    (let x_ : _ = (let _, x = env_ in x)
                    in
                    ( if x_ then param_ else (~-! param_)))) in
    (s, x_)) in
  let z_: _ = (((let env_ : _ = (f_)
    in
    (let code_ : _ = (let x, _ = env_ in x)
    in
    (code_ env_ ((integer_of_string "-1"))))))) in
  {S.z = z_}
```

